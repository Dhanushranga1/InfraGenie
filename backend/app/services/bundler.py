"""
Bundler Service - Deployment Kit Generation

This module creates the final "Deployment Kit" - a downloadable ZIP archive
containing all necessary files for infrastructure deployment: Terraform code,
Ansible playbook, deployment script, and documentation.

The bundler creates a complete, self-contained package that users can download
and execute to provision their infrastructure with a single command.
"""

import io
import zipfile
from typing import Dict, Any
import logging
from datetime import datetime

from app.core.state import AgentState

logger = logging.getLogger(__name__)


# README template for the deployment kit
README_TEMPLATE = """# InfraGenie Deployment Kit

**Generated:** {timestamp}
**Estimated Monthly Cost:** {cost}

## ðŸ“¦ What's Included

This deployment kit contains everything needed to provision and configure your infrastructure:

- **main.tf** - Terraform infrastructure definition
- **playbook.yml** - Ansible configuration management
- **deploy.sh** - Automated deployment script
- **destroy.sh** - Safe infrastructure cleanup script
- **README.md** - This file

## ðŸš€ Quick Start

### Prerequisites

1. **Terraform** (v1.0+)
   ```bash
   terraform --version
   ```

2. **Ansible** (v2.9+)
   ```bash
   ansible --version
   ```

3. **Cloud Provider Credentials**
   - AWS: Configure `aws configure` or set environment variables
   - Ensure you have appropriate IAM permissions

### Deployment Steps

#### Option 1: Automated Deployment (Recommended)

Simply run the deployment script:

```bash
chmod +x deploy.sh
./deploy.sh
```

This script will:
1. Initialize Terraform
2. Provision infrastructure
3. Extract server IP address
4. Run Ansible configuration

#### Option 2: Manual Deployment

**Step 1: Provision Infrastructure**
```bash
terraform init
terraform plan
terraform apply
```

**Step 2: Configure Servers**
```bash
# Get the server IP from Terraform output
terraform output

# Create inventory file
echo "[servers]" > inventory.ini
echo "<YOUR_SERVER_IP>" >> inventory.ini

# Run Ansible playbook
ansible-playbook -i inventory.ini playbook.yml
```

## ðŸ”’ Security Features

This deployment includes:
- âœ… Encrypted storage (where applicable)
- âœ… Security group restrictions
- âœ… fail2ban intrusion prevention
- âœ… Automatic security updates

## ðŸ’° Cost Management

**Estimated Monthly Cost:** {cost}

### Cost Assassin Feature
Your servers are configured with an automatic shutdown at **8 PM daily** to prevent unnecessary costs.

To disable this feature:
```bash
# SSH into your server
ssh user@<server-ip>

# Remove the cron job
sudo crontab -e
# Delete the line containing "Cost Assassin"
```

## ðŸ“ Infrastructure Details

{user_prompt}

## ðŸ§¹ Cleanup

When you're done with your infrastructure, you can safely destroy it:

```bash
./destroy.sh
```

This will:
1. Show you what resources will be destroyed
2. Ask for confirmation
3. Remove all provisioned infrastructure
4. Optionally clean up generated files

**Note:** Terraform maintains a state file (`terraform.tfstate`) that tracks your infrastructure. Keep this file if you plan to make updates to your infrastructure later. If you destroy everything, you can safely delete it.

## ðŸ› ï¸ Troubleshooting

### Terraform Errors

**Issue:** Provider authentication failed
**Solution:** Verify cloud credentials are configured correctly

**Issue:** Resource already exists
**Solution:** Import existing resources or use different names

### Ansible Errors

**Issue:** Cannot connect to host
**Solution:** 
- Verify SSH key is configured
- Check security group allows SSH (port 22)
- Wait 2-3 minutes for instance to fully boot

**Issue:** Permission denied
**Solution:** Ensure SSH key has correct permissions (chmod 600 ~/.ssh/id_rsa)

## ðŸ”§ Customization

### Modify Infrastructure

Edit `main.tf` to adjust resources, then run:
```bash
terraform plan
terraform apply
```

### Modify Configuration

Edit `playbook.yml` to adjust server setup, then run:
```bash
ansible-playbook -i inventory.ini playbook.yml
```

## ðŸ“š Additional Resources

- [Terraform Documentation](https://www.terraform.io/docs)
- [Ansible Documentation](https://docs.ansible.com)
- [InfraGenie Project](https://github.com/Dhanushranga1/InfraGenie)

## âš ï¸ Important Notes

1. **Costs:** Monitor your cloud provider billing dashboard
2. **Security:** Review security group rules before deployment
3. **Backups:** Set up automated backups for production workloads
4. **Auto-shutdown:** Remember the 8 PM daily shutdown (Cost Assassin)

## ðŸ¤ Support

For issues or questions:
- Check the troubleshooting section above
- Review Terraform/Ansible logs
- Consult cloud provider documentation

---

**Generated by InfraGenie** - AI-Powered Infrastructure Automation
"""


# Deployment script template
DEPLOY_SCRIPT_TEMPLATE = """#!/bin/bash

# InfraGenie Deployment Script
# Automated infrastructure provisioning and configuration

set -e  # Exit on error

echo "ðŸš€ InfraGenie Deployment Starting..."
echo "===================================="
echo ""

# Colors for output
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
RED='\\033[0;31m'
NC='\\033[0m' # No Color

# Check prerequisites
echo "ðŸ“‹ Checking prerequisites..."

if ! command -v terraform &> /dev/null; then
    echo "${RED}âŒ Terraform not found. Please install Terraform first.${NC}"
    exit 1
fi

if ! command -v ansible-playbook &> /dev/null; then
    echo "${RED}âŒ Ansible not found. Please install Ansible first.${NC}"
    exit 1
fi

echo "${GREEN}âœ… Prerequisites check passed${NC}"
echo ""

# Terraform deployment
echo "ðŸ—ï¸  Step 1: Provisioning infrastructure with Terraform..."
echo "-------------------------------------------------------"

terraform init
if [ $? -ne 0 ]; then
    echo "${RED}âŒ Terraform init failed${NC}"
    exit 1
fi

terraform validate
if [ $? -ne 0 ]; then
    echo "${RED}âŒ Terraform validation failed${NC}"
    exit 1
fi

echo ""
echo "${YELLOW}âš ï¸  Review the plan carefully before proceeding${NC}"
terraform plan

echo ""
read -p "Do you want to apply this plan? (yes/no): " confirm

if [ "$confirm" != "yes" ]; then
    echo "Deployment cancelled."
    exit 0
fi

terraform apply -auto-approve
if [ $? -ne 0 ]; then
    echo "${RED}âŒ Terraform apply failed${NC}"
    exit 1
fi

echo "${GREEN}âœ… Infrastructure provisioned successfully${NC}"
echo ""

# Extract instance IP
echo "ðŸ“¡ Step 2: Extracting server information..."
echo "-------------------------------------------"

# Try to get instance IP from Terraform output
INSTANCE_IP=$(terraform output -raw instance_ip 2>/dev/null || terraform output -json | jq -r '.instance_ip.value' 2>/dev/null || echo "")

if [ -z "$INSTANCE_IP" ] || [ "$INSTANCE_IP" == "null" ]; then
    echo "${YELLOW}âš ï¸  Could not automatically extract instance IP${NC}"
    echo "Please check Terraform outputs manually:"
    terraform output
    echo ""
    read -p "Enter the server IP address: " INSTANCE_IP
fi

echo "Server IP: $INSTANCE_IP"
echo ""

# Create Ansible inventory
echo "ðŸ“ Step 3: Creating Ansible inventory..."
echo "----------------------------------------"

# Check for generated SSH key
if [ ! -f "infragenie-key.pem" ]; then
    echo "${YELLOW}âš ï¸  SSH key 'infragenie-key.pem' not found${NC}"
    echo "The Terraform code should have generated this key."
    echo "Creating inventory without key specification..."
    
    cat > inventory.ini << EOF
[servers]
$INSTANCE_IP ansible_user=ubuntu ansible_ssh_common_args='-o StrictHostKeyChecking=no'
EOF
else
    echo "${GREEN}âœ… Found generated SSH key: infragenie-key.pem${NC}"
    
    cat > inventory.ini << EOF
[servers]
$INSTANCE_IP ansible_user=ubuntu ansible_ssh_private_key_file=infragenie-key.pem ansible_ssh_common_args='-o StrictHostKeyChecking=no'
EOF
fi

echo "${GREEN}âœ… Inventory created${NC}"
echo ""

# Wait for instance to be ready with intelligent SSH polling
echo "â³ Step 4: Waiting for SSH to be available..."
echo "----------------------------------------------"

RETRIES=0
MAX_RETRIES=30  # 30 attempts * 10 seconds = 5 minutes total timeout
START_TIME=$(date +%s)

# Determine SSH command based on key availability
if [ -f "infragenie-key.pem" ]; then
    echo "${GREEN}âœ… Using generated SSH key: infragenie-key.pem${NC}"
    SSH_CMD="ssh -i infragenie-key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=5 -o BatchMode=yes ubuntu@$INSTANCE_IP exit"
    SSH_USER_CMD="ssh -i infragenie-key.pem ubuntu@$INSTANCE_IP"
else
    echo "${YELLOW}âš ï¸  No SSH key found. Using default SSH authentication${NC}"
    SSH_CMD="ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 -o BatchMode=yes ubuntu@$INSTANCE_IP exit"
    SSH_USER_CMD="ssh ubuntu@$INSTANCE_IP"
fi

echo "Testing SSH connection to $INSTANCE_IP..."
echo ""

until $SSH_CMD 2>/dev/null
do
    RETRIES=$((RETRIES+1))
    ELAPSED=$(($(date +%s) - START_TIME))
    ELAPSED_MIN=$((ELAPSED / 60))
    ELAPSED_SEC=$((ELAPSED % 60))
    
    if [ $RETRIES -ge $MAX_RETRIES ]; then
        echo ""
        echo "${RED}âŒ ERROR: SSH connection failed after $MAX_RETRIES attempts (${ELAPSED_MIN}m ${ELAPSED_SEC}s)${NC}"
        echo ""
        echo "Possible reasons:"
        echo "  1. Instance is still booting (EC2 initialization can take 3-5 minutes)"
        echo "  2. Security group doesn't allow SSH traffic (port 22) from your IP"
        echo "  3. Instance is in a private subnet without public IP"
        if [ ! -f "infragenie-key.pem" ]; then
            echo "  4. SSH key 'infragenie-key.pem' was not found (check Terraform generated it)"
        fi
        echo ""
        echo "Troubleshooting steps:"
        echo "  â€¢ Check AWS Console: EC2 â†’ Instances â†’ Status Checks (should show 2/2 passed)"
        echo "  â€¢ Verify Security Group allows port 22 from your IP"
        echo "  â€¢ Run: terraform show | grep 'public_ip' to confirm instance has public IP"
        if [ -f "infragenie-key.pem" ]; then
            echo "  â€¢ Try manual SSH: $SSH_USER_CMD"
        fi
        echo ""
        exit 1
    fi
    
    # Progressive retry messaging (more detailed as time passes)
    if [ $RETRIES -eq 1 ]; then
        echo "ðŸ”„ Attempt 1/$MAX_RETRIES - Instance launching... (this is normal)"
    elif [ $RETRIES -le 5 ]; then
        echo "ðŸ”„ Attempt $RETRIES/$MAX_RETRIES - Still initializing... (~${ELAPSED}s elapsed)"
    elif [ $RETRIES -le 15 ]; then
        echo "ðŸ”„ Attempt $RETRIES/$MAX_RETRIES - Booting OS... (~${ELAPSED_MIN}m ${ELAPSED_SEC}s elapsed)"
    else
        echo "ðŸ”„ Attempt $RETRIES/$MAX_RETRIES - Taking longer than usual... (~${ELAPSED_MIN}m ${ELAPSED_SEC}s elapsed)"
    fi
    
    sleep 10
done

TOTAL_ELAPSED=$(($(date +%s) - START_TIME))
echo ""
echo "${GREEN}âœ… SSH connection established after ${TOTAL_ELAPSED}s (${RETRIES} attempts)${NC}"
echo ""

# Run Ansible configuration
echo "âš™ï¸  Step 5: Configuring server with Ansible..."
echo "---------------------------------------------"

# Retry logic for Ansible (in case of transient issues)
max_attempts=3
attempt=1

while [ $attempt -le $max_attempts ]; do
    echo "Attempt $attempt of $max_attempts..."
    
    if ansible-playbook -i inventory.ini playbook.yml; then
        echo "${GREEN}âœ… Server configuration completed${NC}"
        break
    else
        if [ $attempt -lt $max_attempts ]; then
            echo "${YELLOW}âš ï¸  Ansible failed, waiting 20 seconds before retry...${NC}"
            sleep 20
            attempt=$((attempt + 1))
        else
            echo "${RED}âŒ Ansible configuration failed after $max_attempts attempts${NC}"
            echo "You can try running Ansible manually:"
            echo "ansible-playbook -i inventory.ini playbook.yml"
            exit 1
        fi
    fi
done

echo ""
echo "===================================="
echo "${GREEN}ðŸŽ‰ Deployment Complete!${NC}"
echo "===================================="
echo ""
echo "ðŸ“Š Deployment Summary:"
echo "  - Infrastructure: Provisioned âœ…"
echo "  - Server IP: $INSTANCE_IP"
echo "  - Configuration: Applied âœ…"
echo "  - Cost Assassin: Active (8 PM shutdown) â°"
echo ""
echo "âš ï¸  Important Reminders:"
echo "  1. Monitor your cloud costs regularly"
echo "  2. Server auto-shuts down at 8 PM daily"
echo "  3. Review security settings in AWS console"
echo "  4. Terraform state is in terraform.tfstate - KEEP THIS FILE for future updates"
echo ""
echo "ðŸ”— Next Steps:"
if [ -f "infragenie-key.pem" ]; then
    echo "  - SSH: ssh -i infragenie-key.pem ubuntu@$INSTANCE_IP"
else
    echo "  - SSH: ssh ubuntu@$INSTANCE_IP"
fi
echo "  - Verify: terraform output"
echo "  - Update: Modify main.tf and run 'terraform apply' again"
echo "  - Cleanup: Run './destroy.sh' or 'terraform destroy' (when done)"
echo ""
echo "Happy deploying! ðŸš€"
"""


# Destroy script template for infrastructure cleanup
DESTROY_SCRIPT_TEMPLATE = """#!/bin/bash

# InfraGenie - Infrastructure Destruction Script
# This script safely destroys all provisioned infrastructure
# Use this when you're done with your deployment

set -e

# Colors for output
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
RED='\\033[0;31m'
NC='\\033[0m' # No Color

echo "âš ï¸  ================================================"
echo "     INFRASTRUCTURE DESTRUCTION"
echo "    ================================================"
echo ""
echo "${YELLOW}WARNING: This will PERMANENTLY DELETE all resources.${NC}"
echo ""
echo "Resources that will be destroyed:"
terraform show -no-color | grep "^resource" || echo "  (Run 'terraform show' to see details)"
echo ""

read -p "Are you absolutely sure? Type 'yes' to continue: " confirm

if [ "$confirm" != "yes" ]; then
    echo "Destruction cancelled."
    exit 0
fi

echo ""
echo "ðŸ—‘ï¸  Starting infrastructure destruction..."
echo "=========================================="
echo ""

# Check if Terraform state exists
if [ ! -f "terraform.tfstate" ]; then
    echo "${YELLOW}âš ï¸  No terraform.tfstate found.${NC}"
    echo "Either infrastructure was never created or state file is missing."
    read -p "Continue with destroy anyway? (yes/no): " force_confirm
    if [ "$force_confirm" != "yes" ]; then
        echo "Destruction cancelled."
        exit 0
    fi
fi

# Run Terraform destroy
terraform destroy -auto-approve

if [ $? -eq 0 ]; then
    echo ""
    echo "===================================="
    echo "${GREEN}âœ… Infrastructure Destroyed${NC}"
    echo "===================================="
    echo ""
    echo "All resources have been removed."
    echo "You can safely delete this directory."
    echo ""
    
    # Optionally remove generated files
    read -p "Remove generated files (terraform.tfstate, infragenie-key.pem)? (yes/no): " cleanup
    if [ "$cleanup" == "yes" ]; then
        rm -f terraform.tfstate terraform.tfstate.backup infragenie-key.pem inventory.ini
        echo "${GREEN}âœ… Cleaned up generated files${NC}"
    fi
else
    echo "${RED}âŒ Destruction failed${NC}"
    echo "Check the error messages above."
    echo "You may need to manually clean up resources in the AWS console."
    exit 1
fi

echo ""
echo "Thank you for using InfraGenie! ðŸ‘‹"
"""


def create_deployment_kit(state: AgentState) -> io.BytesIO:
    """
    Create a complete deployment kit ZIP archive from the workflow state.
    
    This function bundles all generated artifacts into a single downloadable
    ZIP file that contains everything needed to deploy the infrastructure.
    
    Args:
        state (AgentState): Complete workflow state with all generated content:
            - terraform_code: Validated Terraform HCL
            - ansible_playbook: Generated Ansible YAML
            - cost_estimate: Monthly cost string
            - user_prompt: Original request
    
    Returns:
        io.BytesIO: In-memory ZIP file ready for download/streaming
    
    ZIP Contents:
        - main.tf: Terraform infrastructure code
        - playbook.yml: Ansible configuration playbook
        - deploy.sh: Automated deployment script (executable)
        - README.md: Complete documentation
        - inventory.ini: Empty template for Ansible
    
    Example:
        ```python
        state = {
            "terraform_code": "provider \"aws\" {...}",
            "ansible_playbook": "---\\n- name: ...",
            "cost_estimate": "$24.50/mo",
            "user_prompt": "Create EC2 instance"
        }
        
        zip_buffer = create_deployment_kit(state)
        
        # Save to file
        with open("deployment-kit.zip", "wb") as f:
            f.write(zip_buffer.getvalue())
        
        # Or stream via HTTP
        return StreamingResponse(
            zip_buffer,
            media_type="application/zip",
            headers={"Content-Disposition": "attachment; filename=deployment-kit.zip"}
        )
        ```
    
    Implementation:
        - Uses in-memory BytesIO for efficiency
        - Sets proper file permissions (deploy.sh as executable)
        - Includes timestamp for traceability
        - Formats README with user context
        - Validates all required fields present
    """
    logger.info("=" * 60)
    logger.info("BUNDLER: Creating deployment kit")
    
    # Extract state components
    terraform_code = state.get("terraform_code", "")
    ansible_playbook = state.get("ansible_playbook", "")
    cost_estimate = state.get("cost_estimate", "Unknown")
    user_prompt = state.get("user_prompt", "Infrastructure deployment")
    
    # Validate required content
    if not terraform_code:
        logger.warning("No Terraform code in state, using placeholder")
        terraform_code = "# No Terraform code generated\n"
    
    if not ansible_playbook:
        logger.warning("No Ansible playbook in state, using placeholder")
        ansible_playbook = "---\n# No playbook generated\n"
    
    # Create in-memory ZIP file
    zip_buffer = io.BytesIO()
    
    try:
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            
            # Add main.tf
            logger.info("Adding main.tf to kit...")
            zip_file.writestr('main.tf', terraform_code)
            
            # Add playbook.yml
            logger.info("Adding playbook.yml to kit...")
            zip_file.writestr('playbook.yml', ansible_playbook)
            
            # Add deploy.sh with executable permissions
            logger.info("Adding deploy.sh to kit...")
            deploy_info = zipfile.ZipInfo('deploy.sh')
            deploy_info.external_attr = 0o755 << 16  # Unix executable permissions
            zip_file.writestr(deploy_info, DEPLOY_SCRIPT_TEMPLATE)
            
            # Add destroy.sh with executable permissions
            logger.info("Adding destroy.sh to kit...")
            destroy_info = zipfile.ZipInfo('destroy.sh')
            destroy_info.external_attr = 0o755 << 16  # Unix executable permissions
            zip_file.writestr(destroy_info, DESTROY_SCRIPT_TEMPLATE)
            
            # Add README.md
            logger.info("Adding README.md to kit...")
            readme_content = README_TEMPLATE.format(
                timestamp=datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC"),
                cost=cost_estimate,
                user_prompt=user_prompt
            )
            zip_file.writestr('README.md', readme_content)
            
            # Add empty inventory.ini template
            logger.info("Adding inventory.ini template to kit...")
            inventory_template = """# Ansible Inventory
# This file will be populated automatically by deploy.sh
# Or manually add your server IPs here:

[servers]
# your-server-ip ansible_user=ubuntu
"""
            zip_file.writestr('inventory.ini', inventory_template)
        
        # Get file count and size
        zip_buffer.seek(0, 2)  # Seek to end
        zip_size = zip_buffer.tell()
        zip_buffer.seek(0)  # Reset to start
        
        logger.info(f"âœ“ Deployment kit created successfully")
        logger.info(f"  - Size: {zip_size / 1024:.2f} KB")
        logger.info(f"  - Files: main.tf, playbook.yml, deploy.sh, destroy.sh, README.md, inventory.ini")
        
        return zip_buffer
    
    except Exception as e:
        logger.error(f"Error creating deployment kit: {str(e)}")
        logger.exception("Full traceback:")
        
        # Return a minimal ZIP with error info
        error_zip = io.BytesIO()
        with zipfile.ZipFile(error_zip, 'w') as zf:
            zf.writestr('ERROR.txt', f"Failed to create deployment kit: {str(e)}")
        error_zip.seek(0)
        return error_zip
